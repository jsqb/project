それでは解答例を公開します。
あくまでも解答例ですので、この他にも更なる工夫の
余地はあると思います。なんだ、こんなのでいいなら、
こんなアイデアもあるんじゃない、と思いついた方は
お知らせください。
また、ここで示すコードも実装例ですので、他の
コーディング方法で解いたとしても問題ありません。

--------------------------------------------------

本テストはプログラミングテストと題しながら、
実はアルゴリズムやパフォーマンスではなく、
データの分析能力というか発想の柔軟性というか、
そんな感じの視点の有無を診ることを目的として
作成しました。

また、機械学習の経験者なら、これは Classification
（ラベル付き分類）の問題であることに気づくと思い
ます。ですが、ここではCoreJava開発者の候補者の殆ど
は機械学習を知らないだろう、という前提で考えています。
（つまり、機械学習を使わないで解いてみたいと思います）

この類の問題を解く場合、学習フェーズ（データから
ルールを導き出す）と予測フェーズ（ルールを使って
予測する）の２つに分けてコーディングします。
ここでの解答例は予測フェーズのみをコーディングし、
学習フェーズは別途、Excelや紙上で集計した結果から
得たものと想定します。もちろん、学習もJavaコード
で動的に行っても構いません。


今回用意した解答例は以下の５通り＋アルファです。


解答例０）正解率２０％（正当な理由があれば正解とします）
------------------------------
class Solution {
  public int solution(int N) {
    return (int) (Math.random() * 5);
  }
}
------------------------------
（以下「class Solution {}」は省略）


解答例１）正解率３０％
------------------------------
public int solution(int N) {
    return 3;
}
------------------------------


解答例２）正解率５１％
------------------------------
public int solution(int N) {
    if (N == 0) return 1;
    if (N == 3) return 4;
    if (N == 4) return 0;
    return 3; // N = 1 or 2
}
------------------------------


解答例３）正解率５１％
------------------------------
public int solution(int N) {
    return (N + 1) % 5;
}
------------------------------


解答例４）正解率４２％
------------------------------
public int solution(int N) {
    return N != 3 ? 3 : 4;
}
------------------------------


解答例５）正解率２０％
------------------------------
int[] norms = new int[]{4,4,0,1,3,2,3,4,0,3,1,2,3};
int i = 0;
public int solution(int N) {
    return norms[i++ % norms.length];
}
------------------------------


番外編）機械学習
Naive Bayesと決定木のどちらも正解率５１％

---

以下の各解答例について詳細に説明します。


０）最低レベル

そもそも、未来予測なんて不可能なんだから、ランダム
で決めればいいんじゃない、と考えたとします。
そうすると、こんなコードになると思います。

------------------------------
public int solution(int N) {
    return (int) (Math.random() * 5);
}
------------------------------

５ページ中から一つを選ぶ問題なので、これで正解率、
平均２０％（1 / 5 = 0.2）が得られます。
例えば、５つの広告バナーがあり、それをランダムに
出してれば、ユーザの最も気の引く広告を５回に１回
は表示できるだろう、と期待できます。
これは最低ラインですので、この値を上回ることを
目標に、以下考察を行います。


１）最頻値

おそらく、まず頭に浮かべるのは、最も出現頻度が
高い数字が、次に来る可能性が高いのでは、という
アイデアではないでしょうか？
そこで、過去１００回の履歴データの各ページについて
頻度を数えてみましょう。

Page[0] = 18
Page[1] = 17
Page[2] = 19
Page[3] = 30
Page[4] = 16

すると、Page 3 が特出して多く出現していることが
分かります。そこで、単純に、

------------------------------
public int solution(int N) {
    return 3;
}
------------------------------

と、常に 3 を返すだけの関数にします。
これでも約３０％の確率で正解が得られることが期待
できます。とはいえ、ランダムよりマシというレベル
ですね。


２）Nの次に来る値の最頻値

３０％では、まだまだ低いので、最頻値の取り方を
もう少し工夫しましょう。
今度は出現した特定の数字 N の次にどの数字が最も
多く出現するかを調べることにします。

Page[0] ==> [0](0)  [1](8) [2](0)  [3](7)  [4](2)
Page[1] ==> [0](1)  [1](0) [2](7)  [3](8)  [4](1)
Page[2] ==> [0](2)  [1](0) [2](0)  [3](15) [4](2)
Page[3] ==> [0](1)  [1](8) [2](10) [3](0)  [4](11)
Page[4] ==> [0](13) [1](1) [2](2)  [3](0)  [4](0)

Page 0 の次は、Page 1 が８回で最も多く見られています。

同様に、
Page 1 は、Page 3（８回）
Page 2 は、Page 3（１５回）
Page 3 は、Page 4（１１回）
Page 4 は、Page 0（１３回）

が多く見られていることが分かります。
そこで、その結果をそのままコードにしてみます。

------------------------------
public int solution(int N) {
    if (N == 0) return 1;
    if (N == 3) return 4;
    if (N == 4) return 0;
    return 3; // N = 1 or 2
}
------------------------------

これで正解率５１％が得られます。


３）数値の増減　その１

次に数字の並びに何らかの規則性がないか調べてみましょう。
数列を眺めていると、なんとなく、0,1,2,3,4,0,1,..のように
１加算されているパターンが多いことに気づくと思います。
そこで、N番目とN+1番目の数値の増減を調べてみましょう。

 4,-2,-2,1,2,-1,1,1,-4,3,-2,1,1,1,-4,1,2,-1,1
,-1,2,-4,3,-2,1,1,1,-4,1,2,-1,1,1,-4,3,-2,1,1,1
,-3,-1,1,2,-1,1,-1,2,-4,3,-2,1,1,1,-4,1,2,-1,1,1
,-4,3,-2,1,1,1,-2,-2,1,2,-1,1,1,-4,3,-2,1,1,1,-4
,1,2,-1,1,-3,4,-4,3,-2,1,1,1,-4,1,2,-1,1,-2,3,-4

これを数値ごとに出現頻度を数えると、以下のようになります。

-4 ==> 13回
-3 ==> 2回
-2 ==> 12回
-1 ==> 11回
 0 ==> 0回
 1 ==> 41回
 2 ==> 10回
 3 ==> 8回
 4 ==> 2回

すると１増えるパターンが４１回で、特出していることが
分かります。そこで、

------------------------------
public int solution(int N) {
    return (N + 1) % 5;
}
------------------------------

と N+1 を返す関数にすると、これも正解率５１％
が得られます。

これは、ページの並びに意味があり、前から順番に閲覧する
ことを求めるタイプのサイトである可能性を示唆しています。
例えば、e-commerceサイトのチェックアウト処理だと、
カートの確認、住所入力、配送先入力、支払方法入力、
最終確認の順に進んでいきます。
ただ、中には住所は登録済みの住所を使うから住所入力ページ
をスキップしたとか、処理を途中でキャンセルしたり等を
行うこともあるため、必ずしも毎回 N+1 にはならない、
と考えられます。
ちなみに、-4は全ての処理を終えた場合、-1,-2,-3は途中
キャンセルの場合を意味すると考えてもいいと思います。


４）数値の増減　その２

更に増減の出現頻度をよーく見ると、

 0 ==> 0回

増減がゼロは無い、つまり、同じ数字が繰り返されることが
無いことが分かります。
これは同じページに対して何度もリクエストを発行したと
しても、カウントしない仕様になっているのかな、と考えて
もらっていいと思います。

この事実を利用することで、先に紹介した解答例１）の
return 3; のコードを改善することができます。

------------------------------
public int solution(int N) {
    return N != 3 ? 3 : 4;
}
------------------------------

前回の数字が 3 でない(N != 3) 時のみ 3 を返します。
そうでない場合は次に 3 が来ることは期待できないので、
3 以外の数字を返すほうが得策です。
そこで、ここでは 3 の後によく出現する 4 を返却します。
これで正解率４２％が得られます。

正解率はやや低めですが、すべての二階層目の最頻値を
求める必要が無いので、学習にかかる演算コストが少ない、
という特徴があります。
テラ単位のデータ量を扱ったり、オンラインで次々と
動的に学習するケースなど、学習に時間的コストをかけら
れない場面で使えるかもしれません。


５）時間周期

次に、データの時間的な周期に着目したアプローチを
考えてみましょう。
ユーザの行動は、それをいつ実行するかによってパターン
が異なる場合が多く見受けられます。
例えば、朝昼晩、平日と週末、春夏秋冬など、現実の
サイトでも時間帯や季節でアクセス数の変動パターンが
ありますよね。
そこで、過去履歴のデータを、２個ずつ、３個ずつ、
４個ずつ、、、と区切りながらパターンが存在しないか
探ってみると、１３個に区切った時点で明らかにデータ
に偏りがあることが分かります。
以下に過去１００回の履歴を１３個ごとに改行して表示
したものを示します。

{ 0, 4, 2, 0, 1, 3, 2, 3, 4, 0, 3, 1, 2
 ,3, 4, 0, 1, 3, 2, 3, 2, 4, 0, 3, 1, 2
 ,3, 4, 0, 1, 3, 2, 3, 4, 0, 3, 1, 2, 3
 ,4, 1, 0, 1, 3, 2, 3, 2, 4, 0, 3, 1, 2
 ,3, 4, 0, 1, 3, 2, 3, 4, 0, 3, 1, 2, 3
 ,4, 2, 0, 1, 3, 2, 3, 4, 0, 3, 1, 2, 3
 ,4, 0, 1, 3, 2, 3, 0, 4, 0, 3, 1, 2, 3
 ,4, 0, 1, 3, 2, 3, 1, 4, 0 }

第０、１列は 4、第２列は 0、第３列は 1、第４列 4、
という様に列ごとに最頻値を返却すれば、約５０％の
正解率が得られそうです。
例えば、実装コードは以下のようになります。

------------------------------
int[] norms = new int[]{4,4,0,1,3,2,3,4,0,3,1,2,3};
int i = 0;
public int solution(int N) {
    return norms[i++ % norms.length];
}
------------------------------

しかし、残念ながら、このアイデアは成功しません。
正解率は２０％前後と、乱数で予測する場合と変わりま
せん。というのは、今回のテストデータはテストを実行
する度に周期が変動する仕組みになっています。
そのため、ある期間のテスト結果をもとに周期表を作成
しても以降のテストでは全く使えないのです。
しかし、今回の問題文からだけでは、このアイデアが
使えないとは判断できませんし、アイデア自体は十分に
試す価値があるものなので、この類のアプローチでも
正解とします。


６）機械学習

基本的には以上ですが、番外編として機械学習の利用も
試してみました。冒頭でも書いたように、もともとこの
問題は機械学習向けの問題ですので、こちらの解法の方
が、より簡単というか、自然とも言えます。

通常の方法では過去の履歴から人間がロジックを考え出
し、実装しましたが、ここでは人間はどのデータを与え
るかだけを考え、あとはコンピュータにロジックを導き
出してもらいます。

つまり、Nを逐次学習データとして予測エンジンに投入し、
毎回モデルを更新しつつ、予測を行います。
分類器として、どのメソッドを使うかで結果が変わりま
すが、ここでは、Naive Bayesと決定木の２種類で試して
みました。

結果は、どちらの正解率も５１％でした。

また、解答例３）でも考察したように、右肩上がりの
直線で近似できるので、回帰分析を用いても同等の結果
が得られるものと期待できます。

--------------------------------------------------

以上です。
